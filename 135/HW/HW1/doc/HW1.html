
<!-- saved from url=(0052)http://athena.ecs.csus.edu/~gordonvs/135/135hw1.html -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <title>
      CSc-135 Fall 2015 HomeWork 1
    </title>
  </head>

  <body>
    <h3>
      <center>
        CSc 135 -- Fall 2015<br>
        Programming Languages<br>
        Homework 1
      </center>
    </h3>
    <h4>
      <center>
        due Friday Oct 9 at midnight<br>
      </center>
    </h4>

    <hr>
    <pre>
  Consider the following EBNF grammar for a very simple programming language:

       program ::= statemt {statemt}
       statemt ::= asignmt | ifstmt | for | input | output
       asignmt ::= ident ~ exprsn ;
       ifstmt  ::= I comprsn @ {statemt} [% {statemt}] &amp;
       for     ::= F ( asignmt ) ( comprsn) L {statemt} \
       input   ::= N ident {, ident} ;
       output  ::= O ident {, ident } ;
       comprsn ::= ( oprnd opratr oprnd )
       exprsn  ::= factor { sumop factor }
       factor  ::= oprnd { prodop oprnd }
       sumop   ::= + | -
       prodop  ::= * | /
       oprnd   ::= integer | ident | ( exprsn )
       opratr  ::= &lt; | = | &gt; | !
       ident   ::= letter {char}
       char    ::= letter | digit
       integer ::= digit {digit}
       letter  ::= X | Y | Z
       digit   ::= 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7

   The tokens are: ~ ; I @ % &amp; F ( ) L \ N , O + - * / &lt; = &gt; ! X Y Z 0 1 2 3 4 5 6 7
   Nonterminals are shown as lowercase words.

   1. Draw Syntax Diagrams for the above grammar.

   2. Show that the grammar satisfies the two requirements for predictive parsing.
      (it does, you just need to prove it).

   3. Implement a recursive-descent recognizer.
       - Prompt the user for an input stream.
       - The start symbol is *program* (as defined above)
       - Report "legal" or "errors found" (not both!).
           You can report additional information as well, if you want.
           For example, knowing where your program finds an error could
           be helpful for me to assign partial credit, if it's wrong.
       - Assume the input stream is the token stream.  Assume that any
           whitespace has already been stripped out by the lexical scanner.
           (i.e., each token is one character - lexical scanning has been completed)
       - Assume the incoming token stream is terminated with a $.
           Add the $ to the grammar and incorporate it in your answers
           to questions #1 and #2 above, where appropriate.
       - Use Java, C, or C++, or ask your instructor if you wish
           to use another language.
       - Limit your source code to ONE file.
       - Make sure your program works on ATHENA before submitting it.
       - INCLUDE INSTRUCTIONS FOR COMPILING AND RUNNING IN A COMMENT
           BLOCK AT THE TOP OF YOUR PROGRAM.  BE SPECIFIC!!  DON'T JUST
           SAY "use Eclipse" or something like that.  Tell me exactly how
           to compile and run your program, step by step.  Also explain
           any input format particulars that your program expects the
           user to enter.

   4. Attach your source file to the drop box in SacCT.

   5. Turn in your syntax diagrams and satisfaction proof as attachments
        in the same dropbox (in SacCT).  They can be handwritten/scanned,
        or computer-drawn.

    </pre>
    <hr>
      <a href="http://athena.ecs.csus.edu/~gordonvs/135/Recognizer.java">example parser in Java</a>
    <hr>
  


</body></html>